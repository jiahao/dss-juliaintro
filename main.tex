%% Submissions for peer-review must enable line-numbering
%% using the lineno option in the \documentclass command.
%%
%% Preprints and camera-ready submissions do not need
%% line numbers, and should have this option removed.
%%
%% Please note that the line numbering option requires
%% version 1.1 or newer of the wlpeerj.cls file.

\documentclass[fleqn,10pt,lineno]{wlpeerj} % for journal submissions
% \documentclass[fleqn,10pt]{wlpeerj} % for preprint submissions

\usepackage{listings}

\title{Model-based feature extraction from medical instrumentation data in Julia}

\author[1]{Jiahao Chen}

\affil[1]{Computer Science and Artificial Intelligence Laboratory,
       Massachusetts Institute of Technology,
       Cambridge, Massachusetts, 02139}

\keywords{Keyword1, Keyword2, Keyword3}

\begin{abstract}
Dummy abstract text. Dummy abstract text. Dummy abstract text. Dummy abstract text. Dummy abstract text. Dummy abstract text. Dummy abstract text. Dummy abstract text. Dummy abstract text. Dummy abstract text. Dummy abstract text.
\end{abstract}

\begin{document}

\flushbottom
\maketitle
\thispagestyle{empty}


\section{Why does language matter?}

\section{A simple data science task}

\subsection{R}

Here is a solution in R

\lstinputlisting{code/ex1.R}

\subsection{MATLAB}

While MATLAB is not usually thoughto of as a tool for data science, ti it spossible to solve this data science problem in MATLAB. MATLAB provides some higher order functions which trun out to be useful for this particular purpose:

\lstinputlisting{code/ex1.m}

Note that the heavy lifting is done entirely by the \lstinline|accumarray|
function, which applies a reduction (in the functional sense) to a number of
subsets of the second input vector, where each subset is specified by the first
input vector. The fourth argument is the function handle (\lstinline|@mean| in
this case) which defines the reduction. In contrast to the R code, which uses
the data frame as the main abstraction, this MATLAB solution uses purely arrays
(really, matrices). All variables in MATLAB are implicitly matrices. The input
vectors are input as row matrices, which have to be transposed using
\lstinline|'| into column vectors for \lstinline|accumarray| to operate
properly. Finally, we have to specify \lstinline|true| in the sixth argument. As
MATLAB does not have keyword arguments, only positional arguments, a MATLAB
user must take care to input the correct number of arguments, in the correct
order. In this case, the third and fifth arguments (being the dimensions of the
output and the default fill value) are not used, but to preserve the semantics
of each positional arguments, must be explicitly skipped over by specifying the
empty matrix \lstinline|[]|.


\paragraph{APL}
Finally, here is another solution to the same problem in APL:

\lstinputlisting{code/ex1.apl}

APL prides itself in facilitating terse code, using literally the fewest
characters possible to express computation. Similarly to MATLAB, APL provides
one data type, namely arrays, and all computations must be expressed as array
operations.

Most readers are probably unfamiliar with APL, so let's go over each piece of the program separately.

\lstinline| ∪u | produces a new array which contains only the unique entries of
\lstinline|u|. Some people may call it ``uniqfy'', but TODO WHAT DOES APL CALL
IT?
The \lstinline| ∪ | function is a nonstandard extension of APL
2, and can be specified as a user-defined function using the following APL code:
%
\lstinputlisting{code/uniqfy.apl}
%
We refer the interested reader to an APL reference for an explanation of these
symbols.

\lstinline| ∘.= | is a generalized outer product that is emblematic of APL
operations. The inventor of APL, Ken Iverson, noted that matrix-matrix
products, written in ordinary mathematical notation as
\[
C_{ij} = \sum_k A_{ik} \times B_{kj}
\]
%
could be interpreted as a summation $\sum$ reduction over a sequence of
scalar-scalar products $\{A_{i1}\times B_{1j}, A_{i2}\times B_{2j}, \dots\}$.
Hence, the ordinary matrix-matrix product is written as \lstinline|+.×| in APL
(read as TODO XXX), with the reduction function $+$ and scalar function
$\times$ written out explicitly and composed together using the $.$ operator
$.$. One of Iverson's insights was that the outer product of two vectors,
\[
C_{ij} = A_i \times B_j
\]
%
has a related structure, where one simply constructs the scalar products
but omits the reduction. In Iverson's notation, the outer product is simply
\lstinline| ∘.×|, where \lstinline| ∘ | (read as XXX) is a no-op placeholder
signifying the absence of a final reduction.

We are now ready to understand \lstinline| ∘.=|, which is the generalized outer
product generated by the comparison function \lstinline|=|. (Note that APL
distinguishes between operators and functions...XXX). For one-dimensional arrays
\lstinline|u| and \lstinline|v|, \lstinline|u∘.=v| generates a matrix $A$ whose
$(i,j)$th element is 1 if the $i$th element of \lstinline|u| is equal to the
$j$th element of \lstinline|v|, and 0 otherwise. Therefore, \lstinline|(∪u)∘.=u|
\footnote{Note that the parentheses are essential - APL has no notion operator precedence, and
all operators and functions take as input all arguments to their right, or until
the end of a parenthesized expression is encountered. The lack of operator precedence rules is yet another way in which APL differs from many modern languages.}
generates the matrix
%
\begin{lstlisting}
    1 0 0 0 0 1 0 1 0 0
    0 1 0 0 0 0 0 0 0 0
    0 0 1 0 0 0 1 0 1 0
    0 0 0 1 0 0 0 0 0 1
    0 0 0 0 1 0 0 0 0 0
\end{lstlisting}
%
which is the indicator matrix showing exactly which entries of \lstinline|u|
share common values with the uniqfied version of itself, \lstinline| ∪u|.

The construction of this indicator matrix is the key to solving this simple data science problem in APL, as it specifies which should be

Now the + part of the matrix-vector product expresses almost exactly the reduction operation desired! The only thing missing is a scaling factor by the counts of each unique user ID, which is computed by a simple reduction \lstinline|+/v| of each row of the indicator matrix.

The greatest strength of APL, providing an elegance way to reason about array operations, is arguably also its greatest limitation. Inexperienced users may not realize that the reduction of each subset can be  construct the indicator matrix \lstinline|(∪u)∘.=u|. Furthermore, the size of the indicator matrix grows \textit{quadratically} in the worst case with the size of the input data! (APL does not support sparse matrices.) Without for loops, the APL programmer has to generate explicitly a representation of all the indices representing all the subsets of the data to \lstinline|groupby| and \lstinline|summarize|. We encourage the reader to consider how one might write an APL program whose memory requirments scale linearly rather than quadratically, and how such a program might be reimplementing sparse linear algebra.

\section*{Introduction}

The purpose of this paper is to itnoduce Julia and its language features using a case study motivated from analyzing medical instrumentation data, in particular heartbeat signals.

\subsection{A differential equation model for heartbeat data}

When we don't have labeled features in the medical data, we have to find some way to generate these labels
s paper is to We are Julia is aniYour introduction goes here! Some examples of commonly used commands and features are listed below, to help you get started.
is
If you have a question, please use the help menu in the top right of the screen to get in touch. When your article or pre-print is complete, use the "Submit to PeerJ" button in the topbar to send your files to PeerJ.

\subsection*{Abou PeerJ}

PeerJ is an award-winning open access publisher covering the biological and medical sciences.  PeerJ provides authors with three publication venues: \textit{PeerJ} and \textit{PeerJ Computer Science} (peer-reviewed academic journals) and \textit{PeerJ PrePrints} (a 'pre-print server'). See https://peerj.com/about/publications/ for more information.

The PeerJ model allows an author to publish articles in their peer-reviewed journal via the purchase of a lifetime Publication Plan. Prices start from just \$99 (a one-off payment) which entitles an author to the lifetime ability to publish 1 article per year for free. Publication in PeerJ PrePrints is entirely free.

\section*{Some \LaTeX{} Examples}
\label{sec:examples}

Use section and subsection commands to organize your document. \LaTeX{} handles all the formatting and numbering automatically. Use ref and label commands for cross-references.

\subsection*{Figures and Tables}

Use the table and tabular commands for basic tables --- see Table~\ref{tab:widgets}, for example. You can upload a figure (JPEG, PNG or PDF) using the project menu. To include it in your document, use the includegraphics command as in the code for Figure~\ref{fig:view} below.

\begin{figure}[ht]
\centering
%\includegraphics[width=\linewidth]{view}
\caption{An example image.}
\label{fig:view}
\end{figure}

\begin{table}[ht]
\centering
\begin{tabular}{l|r}
Item & Quantity \\\hline
Widgets & 42 \\
Gadgets & 13
\end{tabular}
\caption{\label{tab:widgets}An example table.}
\end{table}

\subsection*{Citations}

LaTeX formats citations and references automatically using the bibliography records in your .bib file, which you can edit via the project menu. Use the cite command for an inline citation, like \cite{Figueredo:2009dg}, and the citep command for a citation in parentheses \citep{Figueredo:2009dg}.

\subsection*{Mathematics}

\LaTeX{} is great at typesetting mathematics. Let $X_1, X_2, \ldots, X_n$ be a sequence of independent and identically distributed random variables with $\text{E}[X_i] = \mu$ and $\text{Var}[X_i] = \sigma^2 < \infty$, and let
$$S_n = \frac{X_1 + X_2 + \cdots + X_n}{n}
      = \frac{1}{n}\sum_{i}^{n} X_i$$
denote their mean. Then as $n$ approaches infinity, the random variables $\sqrt{n}(S_n - \mu)$ converge in distribution to a normal $\mathcal{N}(0, \sigma^2)$.

\subsection*{Lists}

You can make lists with automatic numbering \dots

\begin{enumerate}[noitemsep]
\item Like this,
\item and like this.
\end{enumerate}
\dots or bullet points \dots
\begin{itemize}[noitemsep]
\item Like this,
\item and like this.
\end{itemize}
\dots or with words and descriptions \dots
\begin{description}
\item[Word] Definition
\item[Concept] Explanation
\item[Idea] Text
\end{description}

We hope you find write\LaTeX\ useful for your PeerJ submission, and please let us know if you have any feedback. Further examples with dummy text are included in the following pages.

\section*{Methods}

\lipsum[4] % Dummy text

\begin{equation}
\cos^3 \theta =\frac{1}{4}\cos\theta+\frac{3}{4}\cos 3\theta
\label{eq:refname2}
\end{equation}

\lipsum[5] % Dummy text

\subsection*{Subsection}

\lipsum[6] % Dummy text

\paragraph{Paragraph} \lipsum[7] % Dummy text
\paragraph{Paragraph} \lipsum[8] % Dummy text

\subsection*{Subsection}

\lipsum[9] % Dummy text

\begin{figure}[ht]\centering
%\includegraphics[width=\linewidth]{results}
\caption{In-text Picture}
\label{fig:results}
\end{figure}

Reference to Figure \ref{fig:results}.

\section*{Results and Discussion}

\lipsum[10] % Dummy text

\subsection*{Subsection}

\lipsum[11] % Dummy text

\subsubsection*{Subsubsection}

\lipsum[12] % Dummy text

\subsubsection*{Subsubsection}

\lipsum[14] % Dummy text

\subsection*{Subsection}

\lipsum[15-20] % Dummy text

\section*{Acknowledgments}

So long and thanks for all the fish.

\bibliography{bib}

\end{document}
